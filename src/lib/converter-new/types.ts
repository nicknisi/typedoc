import * as ts from 'typescript';
import { DeclarationReflection, ReferenceType, Type, IntrinsicType, TupleType, ReflectionKind, ReflectionType, IntrinsicTypeFlags } from '../models';
import { Context } from './context';
import { createReferenceType } from './factories';

interface TypeConverter {
    supportsNode?: (context: Context, node: ts.TypeReferenceNode, type?: ts.Type) => boolean;
    supportsType?: (context: Context, type: ts.Type) => boolean;
    convertNode?: (context: Context, node: ts.BindingPattern) => Type;
    convertType?: (context: Context, type: ts.Type) => Type;
}

/**
 * Create a type literal reflection.
 *
 * This is a utility function used by [[convertTypeReferenceNode]] and
 * [[convertTypeReferenceType]] when encountering an object or type literal.
 *
 * A type literal is explicitly set:
 * ```
 * let someValue: {a: string; b: number;};
 * ```
 *
 * An object literal types are usually reflected by the TypeScript compiler:
 * ```
 * function someFunction() { return {a: 'Test', b: 1024}; }
 * ```
 *
 * @param context  The context object describing the current state the converter is in.
 * @param symbol  The symbol describing the type literal.
 * @param node  If known the node which produced the type literal. Type literals that are
 *   implicitly generated by TypeScript won't have a corresponding node.
 * @returns A type reflection representing the given type literal.
 */
function convertLiteral(context: Context, symbol: ts.Symbol, node?: ts.Node): Type {
    for (let declaration of symbol.declarations) {
        if (declaration.kind === ts.SyntaxKind.TypeLiteral ||
                declaration.kind === ts.SyntaxKind.ObjectLiteralExpression) {
            return createReferenceType(context, declaration.parent.symbol);
        } else {
            return createReferenceType(context, declaration.symbol);
        }
    }

    const declaration = new DeclarationReflection();
    declaration.kind = ReflectionKind.TypeLiteral;
    declaration.name = '__type';
    declaration.parent = context.scope;

    context.registerReflection(declaration, null, symbol);
    context.withScope(declaration, () => {
        symbol.declarations.forEach((node) => {
            context.converter.convertNode(context, node);
        });
    });

    return new ReflectionType(declaration);
}

const aliasConverter: TypeConverter = {
    /**
     * Test whether the given node and type definitions represent a type alias.
     *
     * The compiler resolves type aliases pretty early and there is no field telling us
     * whether the given node was a type alias or not. So we have to compare the type name of the
     * node with the type name of the type symbol.
     *
     * @param context  The context object describing the current state the converter is in.
     * @param node  The node that should be tested.
     * @param type  The type of the node that should be tested.
     * @returns TRUE when the given node and type look like a type alias, otherwise FALSE.
     */
    supportsNode(context: Context, node: ts.TypeReferenceNode, type: ts.Type): boolean {
        if (!type || !node || !node.typeName) {
            return false;
        }
        if (!type.symbol) {
            return true;
        }

        const checker = context.checker;
        let symbolName = checker.getFullyQualifiedName(type.symbol).split('.');
        if (!symbolName.length) {
            return false;
        }
        if (symbolName[0].substr(0, 1) === '"') {
            symbolName.shift();
        }

        let nodeName = ts.getTextOfNode(node.typeName).split('.');
        if (!nodeName.length) {
            return false;
        }

        let common = Math.min(symbolName.length, nodeName.length);
        symbolName = symbolName.slice(-common);
        nodeName = nodeName.slice(-common);

        return nodeName.join('.') !== symbolName.join('.');
    },

    /**
     * Create a reflection for the given type alias node.
     *
     * This is a node based converter with no type equivalent.
     *
     * Use [[isTypeAlias]] beforehand to test whether a given type/node combination is
     * pointing to a type alias.
     *
     * ```
     * type MyNumber = number;
     * let someValue: MyNumber;
     * ```
     *
     * @param node  The node whose type should be reflected.
     * @returns  A type reference pointing to the type alias definition.
     */
    convertNode(context: Context, node: ts.TypeReferenceNode): ReferenceType {
        const name = ts.getTextOfNode(node.typeName);
        return new ReferenceType(name, ReferenceType.SYMBOL_ID_RESOLVE_BY_NAME);
    }
};

const arrayConverter: TypeConverter = {
    supportsNode(context: Context, node: ts.ArrayTypeNode): boolean {
        return node.kind === ts.SyntaxKind.ArrayType;
    },

    /**
     * Convert the given array type node to its type reflection.
     *
     * This is a node based converter with no type equivalent.
     *
     * ```
     * let someValue: number[];
     * ```
     *
     * @param context  The context object describing the current state the converter is in.
     * @param node  The array type node that should be converted.
     * @returns The type reflection representing the given array type node.
     */
    convertNode(context: Context, node: ts.ArrayTypeNode): Type {
        let result = context.converter.convertType(context, node.elementType);

        if (result) {
            result.isArray = true;
        } else {
            result = new IntrinsicType('Array');
        }

        return result;
    }
};

const bindingArrayConverter: TypeConverter = {
    /**
     * Test whether this converter can handle the given TypeScript node.
     */
    supportsNode(context: Context, node: ts.BindingPattern): boolean {
        return node.kind === ts.SyntaxKind.ArrayBindingPattern;
    },

    /**
     * Convert the given binding pattern to its type reflection.
     *
     * @param context  The context object describing the current state the converter is in.
     * @param node  The binding pattern that should be converted.
     * @returns The type reflection representing the given binding pattern.
     */
    convertNode(context: Context, node: ts.BindingPattern): Type {
        const types: Type[] = [];

        (node.elements as ts.BindingElement[]).forEach((element) => {
            types.push(context.converter.convertType(context, element));
        });

        return new TupleType(types);
    }
};

const bindingObjectConverter: TypeConverter = {
    /**
     * Test whether this converter can handle the given TypeScript node.
     */
    supportsNode(context: Context, node: ts.BindingPattern): boolean {
        return node.kind === ts.SyntaxKind.ObjectBindingPattern;
    },

    /**
     * Convert the given binding pattern to its type reflection.
     *
     * @param context  The context object describing the current state the converter is in.
     * @param node  The binding pattern that should be converted.
     * @returns The type reflection representing the given binding pattern.
     */
    convertNode(context: Context, node: ts.BindingPattern): Type {
        const declaration = new DeclarationReflection();
        declaration.kind = ReflectionKind.TypeLiteral;
        declaration.name = '__type';
        declaration.parent = context.scope;

        context.registerReflection(declaration, null);
        context.withScope(declaration, context => {
            (node.elements as ts.BindingElement[]).forEach((element) => {
                context.converter.convertNode(context, element);
            });
        });

        return new ReflectionType(declaration);
    }
};

const enumConverter: TypeConverter = {
    /**
     * Test whether this converter can handle the given TypeScript type.
     */
    supportsType(context: Context, type: ts.Type): boolean {
        return !!(type.flags & ts.TypeFlags.Enum);
    },

    /**
     * Convert the given enumeration type to its type reflection.
     *
     * This is a type based converter with no node based equivalent.
     *
     * ```
     * enum MyEnum { One, Two, Three }
     * let someValue: MyEnum;
     * ```
     *
     * @param context  The context object describing the current state the converter is in.
     * @param type  The enumeration type that should be converted.
     * @returns The type reflection representing the given enumeration type.
     */
    convertType(context: Context, type: ts.Type): Type {
        return createReferenceType(context, type.symbol);
    }
};

const intrinsicTypeConverter: TypeConverter = {
    /**
     * Test whether this converter can handle the given TypeScript type.
     */
    supportsType(context: Context, type: ts.Type): boolean {
        return !!(type.flags & IntrinsicTypeFlags);
    },

    /**
     * Convert the given intrinsic type to its type reflection.
     *
     * This is a type based converter with no node based equivalent.
     *
     * ```
     * let someValue: string;
     * ```
     *
     * @param type  The intrinsic type that should be converted.
     * @returns The type reflection representing the given intrinsic type.
     */
    convertType(context: Context, type: ts.Type): IntrinsicType {
        let intrinsicName = context.program.getTypeChecker().typeToString(type);
        return new IntrinsicType(intrinsicName);
    }
};

const referenceTypeConverter: TypeConverter = {
    /**
     * Test whether this converter can handle the given TypeScript node.
     */
    supportsNode(context: Context, node: ts.TypeReferenceNode, type: ts.TypeReference): boolean {
        return !!(type.flags & ts.TypeFlags.Object);
    },

    /**
     * Test whether this converter can handle the given TypeScript type.
     */
    supportsType(context: Context, type: ts.TypeReference): boolean {
        return !!(type.flags & ts.TypeFlags.Object);
    },

    /**
     * Convert the type reference node to its type reflection.
     *
     * This is a node based converter, see [[convertTypeReferenceType]] for the type equivalent.
     *
     * ```
     * class SomeClass { }
     * let someValue: SomeClass;
     * ```
     *
     * @param context  The context object describing the current state the converter is in.
     * @param node  The type reference node that should be converted.
     * @param type  The type of the type reference node.
     * @returns The type reflection representing the given reference node.
     */
    convertNode(context: Context, node: ts.TypeReferenceNode, type: ts.TypeReference): Type {
        if (!type.symbol) {
            return new IntrinsicType('Object');
        } else if (type.symbol.declarations && (type.symbol.flags & ts.SymbolFlags.TypeLiteral || type.symbol.flags & ts.SymbolFlags.ObjectLiteral)) {
            return convertLiteral(context, type.symbol, node);
        }

        const result = createReferenceType(context, type.symbol);
        if (node.typeArguments) {
            result.typeArguments = node.typeArguments.map((n) => context.converter.convertType(context, n));
        }

        return result;
    },

    /**
     * Convert the given type reference to its type reflection.
     *
     * This is a type based converter, see [[convertTypeReference]] for the node equivalent.
     *
     * ```
     * class SomeClass { }
     * let someValue: SomeClass;
     * ```
     *
     * @param context  The context object describing the current state the converter is in.
     * @param type  The type reference that should be converted.
     * @returns The type reflection representing the given type reference.
     */
    convertType(context: Context, type: ts.TypeReference): Type {
        if (!type.symbol) {
            return new IntrinsicType('Object');
        } else if (type.symbol.declarations && (type.symbol.flags & ts.SymbolFlags.TypeLiteral || type.symbol.flags & ts.SymbolFlags.ObjectLiteral)) {
            return convertLiteral(context, type.symbol);
        }

        const result = createReferenceType(context, type.symbol);
        if (type.typeArguments) {
            result.typeArguments = type.typeArguments.map((t) => context.converter.convertType(context, null, t));
        }

        return result;
    }
};

const stringLiteralConverter: TypeConverter = {
};

export function convertType(context: Context, node?: ts.Node, type?: ts.Type): Type {
}
