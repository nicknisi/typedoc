import * as ts from 'typescript';
import * as path from 'path';

import { EventDispatcher } from '../utils/events';
import { Reflection, Type, ProjectReflection } from '../models';
import { Context } from './context';
import { normalizePath } from '../utils/fs';

import { createSourceFile, createClass, createDecorator, resolveDecorators, createFunction, createInterface, createEnum, createObjectLiteral, createTypeLiteral, createModule, createSignatureCall, createIndexSignature, createVariable, createVariableStatement } from './factories';
import { isExtendsClause, isImplementsClause } from './utils';

import '../converter/nodes';
import '../converter/types';
// import * as plugins from '../converter/plugins';

/**
 * Result structure of the [[Converter.convert]] method.
 */
export interface ConverterResult {
    /**
     * An array containing all errors generated by the TypeScript compiler.
     */
    errors: ts.Diagnostic[];

    /**
     * The resulting project reflection.
     */
    project: ProjectReflection;
}

export enum SourceFileMode {
    File, Modules
}

export interface ConverterOptions {
    compilerOptions: ts.CompilerOptions;
    fileNames: string[];

    name?: string;
    externalPattern?: string;
    includeDeclarations?: boolean;
    excludeExternals?: boolean;
    excludeNotExported?: boolean;
    excludePrivate?: boolean;
    mode?: SourceFileMode;
    readme?: string;
}

function createCompilerHost(converter: Converter): ts.CompilerHost {
    return {
        getSourceFile(filename: string, languageVersion: ts.ScriptTarget, onError?: (message: string) => void): ts.SourceFile {
            let text: string;
            try {
                text = ts.sys.readFile(filename, converter.options.compilerOptions.charset);
            } catch (e) {
                if (onError) {
                    onError(e.number === ERROR_UNSUPPORTED_FILE_ENCODING ? 'Unsupported file encoding' : e.message);
                }
                text = '';
            }

            return text !== undefined ? ts.createSourceFile(filename, text, languageVersion) : undefined;
        },

        getDefaultLibFileName(options: ts.CompilerOptions): string {
            const lib = converter.getDefaultLib();
            const dir = ts.getDirectoryPath(normalizePath(require.resolve('typescript')));
            return path.join(dir, lib);
        },

        getCurrentDirectory(this: ts.CompilerHost): string {
            const currentDirectory = ts.sys.getCurrentDirectory();
            this.getCurrentDirectory = () => currentDirectory;
            return currentDirectory;
        },

        useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,

        getDirectories: ts.sys.getDirectories,
        fileExists: ts.sys.fileExists,
        directoryExists: ts.sys.directoryExists,
        readFile: ts.sys.readFile,
        getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ?
            (fileName: string) => fileName :
            (fileName: string) => fileName.toLowerCase()
        ,
        getNewLine: () => ts.sys.newLine,

        writeFile(fileName: string, data: string, writeByteOrderMark: boolean, onError?: (message: string) => void) { }
    };
}

/**
 * Return code of ts.sys.readFile when the file encoding is unsupported.
 */
const ERROR_UNSUPPORTED_FILE_ENCODING = -2147024809;

/**
 * Compiles source files using TypeScript and converts compiler symbols to reflections.
 */
export class Converter extends EventDispatcher {
    options: ConverterOptions;

    private compilerHost: ts.CompilerHost;
    private program: ts.Program;
    checker: ts.TypeChecker;
    private project: ProjectReflection;

    private nodeConverters: Map<ts.SyntaxKind, any>;
    private typeNodeConverters: any[];
    private typeTypeConverters: any[];
    private plugins: any[];

    /**
     * General events
     */

    /**
     * Triggered when the converter begins converting a project.
     * The listener should implement [[IConverterCallback]].
     * @event
     */
    static EVENT_BEGIN = 'begin';

    /**
     * Triggered when the converter has finished converting a project.
     * The listener should implement [[IConverterCallback]].
     * @event
     */
    static EVENT_END = 'end';

    /**
     * Factory events
     */

    /**
     * Triggered when the converter begins converting a source file.
     * The listener should implement [[IConverterNodeCallback]].
     * @event
     */
    static EVENT_FILE_BEGIN = 'fileBegin';

    /**
     * Triggered when the converter has created a declaration reflection.
     * The listener should implement [[IConverterNodeCallback]].
     * @event
     */
    static EVENT_CREATE_DECLARATION = 'createDeclaration';

    /**
     * Triggered when the converter has created a signature reflection.
     * The listener should implement [[IConverterNodeCallback]].
     * @event
     */
    static EVENT_CREATE_SIGNATURE = 'createSignature';

    /**
     * Triggered when the converter has created a parameter reflection.
     * The listener should implement [[IConverterNodeCallback]].
     * @event
     */
    static EVENT_CREATE_PARAMETER = 'createParameter';

    /**
     * Triggered when the converter has created a type parameter reflection.
     * The listener should implement [[IConverterNodeCallback]].
     * @event
     */
    static EVENT_CREATE_TYPE_PARAMETER = 'createTypeParameter';

    /**
     * Triggered when the converter has found a function implementation.
     * The listener should implement [[IConverterNodeCallback]].
     * @event
     */
    static EVENT_FUNCTION_IMPLEMENTATION = 'functionImplementation';

    /**
     * Resolve events
     */

    /**
     * Triggered when the converter begins resolving a project.
     * The listener should implement [[IConverterCallback]].
     * @event
     */
    static EVENT_RESOLVE_BEGIN = 'resolveBegin';

    /**
     * Triggered when the converter resolves a reflection.
     * The listener should implement [[IConverterResolveCallback]].
     * @event
     */
    static EVENT_RESOLVE = 'resolveReflection';

    /**
     * Triggered when the converter has finished resolving a project.
     * The listener should implement [[IConverterCallback]].
     * @event
     */
    static EVENT_RESOLVE_END = 'resolveEnd';

    static nodeConverterClasses: any[] = [];

    static typeConverterClasses: any[] = [];

    static pluginClasses: any[] = [];

    constructor(options: ConverterOptions) {
        super();

        this.options = Object.assign({}, options);
        this.options.fileNames = options.fileNames.map(fileName => ts.normalizeSlashes(fileName));

        this.compilerHost = createCompilerHost(this);
        this.program = ts.createProgram(
            this.options.fileNames,
            this.options.compilerOptions,
            this.compilerHost
        );
        this.checker = this.program.getTypeChecker();
        this.project = new ProjectReflection(this.options.name);

        this.nodeConverters = new Map();
        for (let ctor of Converter.nodeConverterClasses) {
            this.addNodeConverter(ctor);
        }

        this.typeTypeConverters = [];
        this.typeNodeConverters = [];
        for (let ctor of Converter.typeConverterClasses) {
            this.addTypeConverter(ctor);
        }
        this.typeNodeConverters.sort((a, b) => b.priority - a.priority);
        this.typeTypeConverters.sort((a, b) => b.priority - a.priority);

        this.plugins = [];
        for (let ctor of Converter.pluginClasses) {
            this.plugins.push(new ctor(this));
        }
    }

    private addNodeConverter(componentClass: any) {
        const converter = new componentClass(this);
        for (let kind of componentClass.supports) {
            this.nodeConverters.set(kind, converter);
        }
    }

    private addTypeConverter(converterClass: any) {
        /*const converter = new converterClass(this);

        if (types.isNodeTypeConverter(converter)) {
            this.typeNodeConverters.push(converter);
        }

        if (types.isTypeTypeConverter(converter)) {
            this.typeTypeConverters.push(converter);
        }*/
    }

    /**
     * Compile the given source files and create a project reflection for them.
     */
    convert(): ConverterResult {
        const context = new Context(this, this.options.fileNames, this.checker, this.program);

        this.trigger(Converter.EVENT_BEGIN, context);

        debugger;
        this.program.getSourceFiles().forEach(sourceFile => {
            this.visit(sourceFile, context);
        });
        const errors = this.getErrors();
        const project = this.resolve(context);

        this.trigger(Converter.EVENT_END, context);

        return {
            errors,
            project
        };
    }

    visit(node: ts.Node, context: Context) {
        if (ts.isDecorator(node)) {
            createDecorator(context, node);
        } else if (node.kind === ts.SyntaxKind.Block || node.kind === ts.SyntaxKind.ModuleBlock) {
            ts.forEachChild(node, child => this.visit(child, context));
        } else if (isExtendsClause(node)) {
        } else if (isImplementsClause(node)) {
        } else {
            this.convertNode(context, node);
        }
    }

    getReflectionFromSymbol(symbol: ts.Symbol): Reflection {
        return this.project.symbolMap.get(symbol);
    }

    registerReflection(reflection: Reflection, node: ts.Node, isInherit: boolean, symbol?: ts.Symbol) {
        this.project.reflections[reflection.id] = reflection;

        symbol = symbol || (node ? node.symbol : null);
        if (!isInherit && symbol && !this.project.symbolMap.has(symbol)) {
            this.project.symbolMap.set(symbol, reflection);
        }
    }

    /**
     * Analyze the given node and create a suitable reflection.
     *
     * This function checks the kind of the node and delegates to the matching function implementation.
     *
     * @param context  The context object describing the current state the converter is in.
     * @param node     The compiler node that should be analyzed.
     * @return The resulting reflection or NULL.
     */
    convertNode(context: Context, node: ts.Node): Reflection {
        // TODO: look into why `as any`
        if (ts.isSourceFile(node)) {
            return createSourceFile(context, node, this.options.mode !== SourceFileMode.File);
        } else if (ts.isClassLike(node)) {
            return createClass(context, node as any);
        } else if (ts.isMethodDeclaration(node) || node.kind === ts.SyntaxKind.FunctionDeclaration || node.kind === ts.SyntaxKind.MethodSignature) {
            return createFunction(context, node as any);
        } else if (node.kind === ts.SyntaxKind.InterfaceDeclaration) {
            return createInterface(context, node as any);
        } else if (node.kind === ts.SyntaxKind.EnumDeclaration) {
            return createEnum(context, node as any);
        } else if (ts.isObjectLiteralExpression(node)) {
            return createObjectLiteral(context, node as any);
        } else if (node.kind === ts.SyntaxKind.TypeLiteral) {
            return createTypeLiteral(context, node as any);
        } else if (node.kind === ts.SyntaxKind.ModuleDeclaration) {
            return createModule(context, node as any);
        } else if ([ts.SyntaxKind.CallSignature, ts.SyntaxKind.FunctionType, ts.SyntaxKind.FunctionExpression, ts.SyntaxKind.ArrowFunction].find(kind => kind === node.kind)) {
            return createSignatureCall(context, node as any);
        } else if (node.kind === ts.SyntaxKind.IndexSignature) {
            return createIndexSignature(context, node as any);
        } else if ([ts.SyntaxKind.PropertySignature, ts.SyntaxKind.PropertyDeclaration, ts.SyntaxKind.PropertyAssignment, ts.SyntaxKind.ShorthandPropertyAssignment, ts.SyntaxKind.VariableDeclaration, ts.SyntaxKind.BindingElement].find(kind => kind === node.kind)) {
            return createVariable(context, node as any);
        } else if (node.kind === ts.SyntaxKind.VariableStatement) {
            return createVariableStatement(context, node as any);
        }
        return null;
    }

    /**
     * Convert the given TypeScript type into its TypeDoc type reflection.
     *
     * @param context  The context object describing the current state the converter is in.
     * @param node  The node whose type should be reflected.
     * @param type  The type of the node if already known.
     * @returns The TypeDoc type reflection representing the given node and type.
     */
    convertType(context: Context, node?: ts.Node, type?: ts.Type): Type {
        // Run all node based type conversions
        if (node) {
            type = type || context.getTypeAtLocation(node);

            for (let converter of this.typeNodeConverters) {
                if (converter.supportsNode(context, node, type)) {
                    return converter.convertNode(context, node, type);
                }
            }
        }

        // Run all type based type conversions
        if (type) {
            for (let converter of this.typeTypeConverters) {
                if (converter.supportsType(context, type)) {
                    return converter.convertType(context, type);
                }
            }
        }
    }

    /**
     * Get the errors that may have been generated by the TypeScript compiler
     *
     * @returns An array containing all errors generated by the TypeScript compiler.
     */
    private getErrors(): ts.Diagnostic[] {
        let diagnostics = this.program.getOptionsDiagnostics();
        if (diagnostics.length) {
            return diagnostics;
        }

        diagnostics = this.program.getSyntacticDiagnostics();
        if (diagnostics.length) {
            return diagnostics;
        }

        diagnostics = this.program.getGlobalDiagnostics();
        if (diagnostics.length) {
            return diagnostics;
        }

        diagnostics = this.program.getSemanticDiagnostics();
        if (diagnostics.length) {
            return diagnostics;
        }

        return [];
    }

    /**
     * Resolve the project within the given context.
     *
     * @param context  The context object describing the current state the converter is in.
     */
    private resolve(context: Context): ProjectReflection {
        this.trigger(Converter.EVENT_RESOLVE_BEGIN, context);
        const project = context.project;

        for (let id in project.reflections) {
            if (!project.reflections.hasOwnProperty(id)) {
                continue;
            }
            this.trigger(Converter.EVENT_RESOLVE, context, project.reflections[id]);
        }

        resolveDecorators(this);

        this.trigger(Converter.EVENT_RESOLVE_END, context);
        return project;
    }

    /**
     * Return the basename of the default library that should be used.
     *
     * @returns The basename of the default library.
     */
    getDefaultLib(): string {
        return ts.getDefaultLibFileName(this.options.compilerOptions);
    }
}
